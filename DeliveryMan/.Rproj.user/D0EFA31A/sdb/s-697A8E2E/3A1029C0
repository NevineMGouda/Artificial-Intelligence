{
    "collab_server" : "",
    "contents" : "list.of.packages <- c(\"igraph\")\nnew.packages <- list.of.packages[!(list.of.packages %in% installed.packages()[,\"Package\"])]\nif(length(new.packages)) install.packages(new.packages)\nlibrary(igraph)\n\n#' @export\nrandomWC=function(moveInfo,readings,positions,edges,probs) {\n  moveInfo$moves=c(sample(getOptions(positions[3],edges),1),0)  \n  return(moveInfo)\n}\n\n#' @export\nmanualWC=function(moveInfo,readings,positions,edges,probs) {\n  options=getOptions(positions[3],edges)\n  print(\"Move 1 options (plus 0 for search):\")\n  print(options)\n  mv1=readline(\"Move 1: \")\n  if (mv1==\"q\") {stop()}\n  if (!mv1 %in% options && mv1 != 0) {\n    warning (\"Invalid move. Search ('0') specified.\")\n    mv1=0\n  }\n  if (mv1!=0) {\n    options=getOptions(mv1,edges)\n  }\n  print(\"Move 2 options (plus 0 for search):\")\n  print(options)\n  mv2=readline(\"Move 2: \")    \n  if (mv2==\"q\") {stop()}\n  if (!mv1 %in% options && mv1 != 0) {\n    warning (\"Invalid move. Search ('0') specified.\")\n    mv2=0\n  }\n  moveInfo$moves=c(mv1,mv2)\n  return(moveInfo)\n}\n\ngetProbabilities= function(croc_readings, sensors_prob){\n  states_count =nrow(sensors_prob$salinity)\n  sensors_count = length(croc_readings)\n  probabilities =  matrix (nrow=states_count, ncol=sensors_count)\n  colnames(probabilities) <-c(\"salinity\",\"phosphate\",\"nitrogen\")\n  # j = 1 => salinity\n  # j = 2 => phosphate\n  # j = 3 => nitrogen\n  for (j in 1:sensors_count){\n    croc_sensor = croc_readings[j]\n    for (i in 1:states_count){\n      if (j==1){\n        mean_val = sensors_prob$salinity[i,1]\n        standard_dev = sensors_prob$salinity[i,2]\n        probabilities[i,\"salinity\"] = dnorm(croc_sensor, mean= mean_val, sd=standard_dev)\n      }\n      else if(j == 2){\n        mean_val = sensors_prob$phosphate[i,1]\n        standard_dev = sensors_prob$phosphate[i,2]\n        probabilities[i,\"phosphate\"] = dnorm(croc_sensor, mean= mean_val, sd=standard_dev)\n      }\n      else{\n        mean_val = sensors_prob$nitrogen[i,1]\n        standard_dev = sensors_prob$nitrogen[i,2] \n        probabilities[i,\"nitrogen\"] = dnorm(croc_sensor, mean= mean_val, sd=standard_dev)\n      }\n    }\n  }\n  return(probabilities)\n}\n\ngetNeighbours = function(states_edges, size){\n  new_edges = matrix(c(states_edges[1,]),ncol = 2)\n  edges_count = nrow(states_edges) \n  dict = list()\n  for (i in 1:edges_count){\n    state = states_edges[i, 1]\n    neighbour = states_edges[i, 2]\n    dict_state = dict[[toString(state)]]\n    dict_neighbour = dict[[toString(neighbour)]]\n    if (is.null(dict_state)){\n      dict[[toString(state)]] = c(state, neighbour)\n      \n    }\n    else{\n      dict[[toString(state)]] = c(dict[[toString(state)]], neighbour)\n    }\n    \n    if (is.null(dict_neighbour)){\n      dict[[toString(neighbour)]] = c(state, neighbour)\n    }\n    else{\n      dict[[toString(neighbour)]] = c(dict[[toString(neighbour)]], state)\n    }\n  }\n  return(dict)\n}\n\ngetTransitionMatrix = function(neighbours_list, size){\n  transition_matrix = matrix(0,ncol=size, nrow=size)\n  for (i in 1:length(neighbours_list)){\n    state_index = toString(i)\n    neighbours = neighbours_list[[state_index]]\n    prob = 1/length(neighbours)\n    for(j in 1:length(neighbours)){\n      neighbour_index = neighbours[j]\n      transition_matrix[i,neighbour_index] = prob\n    }\n  }\n  return(transition_matrix)\n}\n\nshortest_path = function(edges, start, goal){\n  new_edges = as.vector(t(edges))\n  g<-graph(new_edges, n=max(new_edges), directed=FALSE)\n  #plot(g)\n  shortest_path_info = get.shortest.paths(g, from=start, to=goal)\n  nodes_to_goal=length(shortest_path_info$vpath[[1]])\n  nodes = matrix(ncol=nodes_to_goal, nrow=1)\n  for(i in 1:nodes_to_goal){\n    nodes[i] = shortest_path_info$vpath[[1]][i]\n  }\n  return(nodes)\n}\n\nforwardalg = function(neighbours_list, previous_forward, emission, transition_matrix){\n  states_count = length(previous_forward)\n  #forward_next = matrix(0,ncol = states_count, nrow = 1)\n  forward_next = rep_len(0,states_count)\n  sum = 0\n  # Each iteration calculates f ~ summ(F((t-1)i) * T(in)) En where summation is done where i = index of neighbours of current state\n  for (i in 1:states_count){\n    state_prob = 0\n    state_index = toString(i)\n    neighbours = neighbours_list[[state_index]]\n    state_emission_value = emission[i]\n    for (j in 1:length(neighbours)){\n      neighbour_index = neighbours[j]\n      transition_value = transition_matrix[neighbour_index, i]\n      neighbour_previous_forward = previous_forward[j]\n      state_prob = state_prob + (previous_forward * transition_value)\n    }\n    state_prob = state_prob * state_emission_value\n    sum = sum + state_prob\n    forward_next[i] = state_prob\n  }\n  # Normalize probabilities\n  for(i in 1:states_count){\n    value = forward_next[i]/sum\n    forward_next[i] = value\n  }\n  return(forward_next)\n}\n\nchoose_next_step = function(path, player_position, state_max_probability, max_probability){\n  if(length(path) < 2 | player_position==path[2]){\n    actions = c(0, 0)\n  }\n  #a most probable state and its at least 2 steps away then get as closer to it as possible\n  else if (state_max_probability!=path[2] && state_max_probability!=path[3] && max_probability>0.8){\n    actions = c(path[2], path[3])\n  }\n  #a most probable state and it is 1 step away then get go to the node and then explore it\n  ## mesh kda mmkn tkon el ableha wasn't searched?\n  else if(state_max_probability!=path[2] && state_max_probability==path[3] && max_probability>0.8){\n    actions = c(path[2], 0)\n  }\n  else{\n    actions = c(0, path[2])\n  }\n  return(actions)\n}\n\nourAlgorithm = function(moveInfo, readings, positions, edges, probs){\n  states_count =nrow(probs$salinity)\n  #Check if this is the first iteration\n  if(length(moveInfo$mem)==0){\n    #Create initial_f, neighbours list and transistion matrix\n    neighbours_list=getNeighbours(states_edges = edges, size = states_count)\n    transition_matrix = getTransitionMatrix(neighbours_list = neighbours_list, size = states_count)\n    #initial_f = [0.025, 0.025, 0.025, 0.025, 0.025, ...] where length(initial_f) = 40\n    # Since the initial probability that the croc is at any state is equal 1/n where n is the number of possible water holes, in this case n = 40\n    previous_forward = matrix(1/states_count, ncol = states_count, nrow=1)\n  }\n  else{\n    neighbours_list = moveInfo$mem$neighbours_list\n    transition_matrix = moveInfo$mem$transition_matrix\n    previous_forward = moveInfo$mem$forward_vector\n  }\n  # returns a matrix of probabilities of size 40x3\n  breakdown_probabilities = getProbabilities(croc_readings = readings, sensors_prob = probs)\n  # create a vector of size 40x1 of probabilities\n  probabilities = t(rowSums(breakdown_probabilities))\n  probabilities = t(breakdown_probabilities[,1] * breakdown_probabilities[,2] * breakdown_probabilities[,3])\n  forward_vector = forwardalg(neighbours_list=neighbours_list, previous_forward=previous_forward, emission=probabilities, transition_matrix=transition_matrix)\n  #The state with the maximum probability to hold the croc\n  state_max_probability = which.max(forward_vector)\n  #That state's probability\n  max_probability = forward_vector[state_max_probability]\n  player_position = positions[3]\n  bp1_position=positions[1]\n  bp2_position=positions[2]\n  # If the crocodile just killed BackPacker1 then just find the shorest path towards the BackPacker1\n  if(!is.na(bp1_position) && bp1_position<0){\n    goal = abs(bp1_position)\n  }\n  # If the crocodile just killed BackPacker2 then just find the shorest path towards the BackPacker2\n  else if(!is.na(bp2_position) && bp2_position<0){\n    goal = abs(bp2_position)\n  }\n  #else Find shortest_path based between player position and most probable state.\n  else{\n    goal = state_max_probability\n  }\n  path = shortest_path(edges, start=player_position, goal=goal)\n  next_steps = choose_next_step(path=path,player_position=player_position, state_max_probability, max_probability=max_probability)\n  moveInfo$moves=next_steps\n  moveInfo$mem=list(forward_vector=forward_vector,neighbours_list=neighbours_list,transition_matrix=transition_matrix)\n  return(moveInfo)\n}\n#' Run Where's Croc\n#' \n#' Runs the Where's Croc game. In this game, you are a ranger in an Australian national park. \n#' This park consists of a number of waterholes, some of which are connected to each other.\n#' There is a crocodile in the park called 'Croc'. Croc has been fitted with sensors that record \n#' the salinity, phosphate and nitrogen levels in the water where he is swimming. He was also \n#' fitted with a sensor that records his position, but that has broken.\n#' Your task is to find Croc using the available information. To aid in this you have information\n#' about the probability distributions for different salinity, phosphate and nitrogen levels in \n#' different waterholes.\n#' There are also two tourists in the park. Both the tourists and Croc walk randomly, each turn\n#' moving to one of the neighboring waterholes from where they are or staying still. All moves\n#' are equally likely.\n#' If Croc and a tourist end up on the same waterhole, Croc will eat the tourist. If you search\n#' the waterhole you are on when Croc is there, you have found Croc and win the game. \n#' Your score is the number of turns it takes to find Croc.\n#' To play manually pass manualWC\n#' as the makeMoves function an`d enter the appropriate numbers to make moves.\n#' @param makeMoves Your function that takes five arguments: (1) A list of information for the move.\n#' This has two fiels. The first is a vector of numbers called 'moves', where you will enter \n#' the moves you want to make. You should\n#' enter two moves (so you can move to a neighboring waterhole and search). Valid moves are the \n#' numbers of a neighboring or current waterhole or '0' which means you will search your current\n#' waterhole for Croc. The second field is a list called\n#' 'mem' that you can use to store information you want to remember from turn to turn. (2) A \n#' vector giving the salinity, phosphate and nitrogen reading from Croc sensors at his current \n#' location. (3) A vector giving the positions of the two tourists and yourself. If a tourist\n#' has just been eaten by Croc that turn, the position will be multiplied by -1. If a tourist \n#' was eaten by Croc in a previous turn, then the position will be NA. (4) a matrix giving the \n#' edges paths between waterholes (edges) present. (5) a list of three matrices giving the mean\n#' and standard deviation of readings for salinity, phosphate and nitrogen respectively\n#' at each waterhole.\n#' Your function should return the first argument passed with an updated moves vector \n#' and any changes to the 'mem' field you wish to access later on.\n#' @param showCroc A Boolean value specifying whether you want Croc to be shown on the gameboard.\n#' Note that you are not permitted to use this visual information when you are scored.\n#' @param pause The pause period between moves. Ignore this.\n#' @return A string describing the outcome of the game.\n#' @export\nrunWheresCroc=function(makeMoves=ourAlgorithm,showCroc=F,pause=1) {\n  #sets initial positions in the grid randomly for our 4 points\n  positions=sample(1:40,4) # Croc, BP1, BP2, Player\n  #gets the blue dots coordinates (fixed)\n  points=getPoints()\n  #gets the edges between the blue points (fixed)\n  edges=getEdges()\n  #gets the probability (mean and standard deviation) for the sensors records (salinity, phosphate and nitrogen)\n  probs=getProbs()\n  # Initialize the game moves count to 0\n  move=0\n  moveInfo=list(moves=c(),mem=list())\n  # while the croc isn't found\n  while (!is.na(positions[1])) {\n    move=move+1\n    # moves the croc after each step to a neighbouring point\n    positions[1]=sample(getOptions(positions[1],edges),1)\n    # If BP1 is not dead and wasn't eaten in the previous step then the BP1 is moved to a neighbouring point\n    # Else if the BP1 was just eaten in the previous step (-1) then change his status to NA\n    if (!is.na(positions[2])&&positions[2]>0) {\n      positions[2]=sample(getOptions(positions[2],edges),1)\n    } else if (!is.na(positions[2]) && positions[2]<0) {\n      positions[2]=NA\n    }\n    # the same thing happens with BP2 as BP1\n    if (!is.na(positions[3])&&positions[3]>0) {\n      positions[3]=sample(getOptions(positions[3],edges),1)\n    } else if (!is.na(positions[3]) && positions[3]<0) {\n      positions[3]=NA\n    }\n    # If BP1 is alive but is in the same waterhole as the croc then BP1 is dead (-position)\n    if (!is.na(positions[2]) && positions[2]==positions[1]) {\n      positions[2]=-positions[2]\n    }\n    # the same thing happens with BP2 as BP1\n    if (!is.na(positions[3]) && positions[3]==positions[1]) {\n      positions[3]=-positions[3]\n    }\n    # plots the game\n    plotGameboard(points,edges,move,positions,showCroc)\n    \n    Sys.sleep(pause)\n    \n    readings=getReadings(positions[1],probs)\n    #oural(moveInfo = moveInfo, readings = readings, positions = positions[2:4], edges = edges, probs = probs)\n    \n    # calling the algorithm or manual implementation of the game\n    moveInfo=makeMoves(moveInfo,readings,positions[2:4],edges,probs)\n    \n    if (length(moveInfo$moves)!=2) {\n      stop(\"Error! Passed makeMoves function should return a vector of two elements.\")\n    }\n    # implementing the moves returned from the function call\n    for (m in moveInfo$moves) {\n      #if move = 0 then it means search the current waterhole of the player\n      if (m==0) {\n        # IF the current hole is the position of the croc it ends the game\n        # and returns the number of moves required to find the croc\n        # else it makes sure that the move is a valid move and then move the player to a neighbouring blue point\n        if (positions[1]==positions[4]) {\n          print(paste(\"Congratualations! You got croc at move \",move,\".\",sep=\"\"))\n          return (move)\n        }\n      } else {\n        if (m%in%getOptions(positions[4],edges)) {\n          positions[4]=m\n        } else {\n          warning(\"Invalid move.\")\n        }\n      }      \n    }\n  }\n}\n#' @export\ngetPoints=function() {\n  points=matrix(c(1,1),ncol=2)\n  points=rbind(points,c(1,7))\n  points=rbind(points,c(1,17))\n  points=rbind(points,c(2,3))\n  points=rbind(points,c(2,12))\n  points=rbind(points,c(3,2))\n  points=rbind(points,c(3,19))\n  points=rbind(points,c(4,7))\n  points=rbind(points,c(4,11))\n  points=rbind(points,c(5,5))\n  points=rbind(points,c(5,15))\n  points=rbind(points,c(6,1))\n  points=rbind(points,c(6,20))\n  points=rbind(points,c(7,6))\n  points=rbind(points,c(7,11))\n  points=rbind(points,c(8,2))\n  points=rbind(points,c(8,14))\n  points=rbind(points,c(8,18))\n  points=rbind(points,c(9,6))\n  points=rbind(points,c(10,10))\n  points=rbind(points,c(10,18))\n  points=rbind(points,c(11,1))\n  points=rbind(points,c(11,12))\n  points=rbind(points,c(12,6))\n  points=rbind(points,c(12,12))\n  points=rbind(points,c(13,16))\n  points=rbind(points,c(14,4))\n  points=rbind(points,c(14,12))\n  points=rbind(points,c(14,20))\n  points=rbind(points,c(15,3))\n  points=rbind(points,c(15,8))\n  points=rbind(points,c(15,17))\n  points=rbind(points,c(16,14))\n  points=rbind(points,c(17,3))\n  points=rbind(points,c(17,18))\n  points=rbind(points,c(18,10))\n  points=rbind(points,c(19,13))\n  points=rbind(points,c(20,2))\n  points=rbind(points,c(20,6))\n  points=rbind(points,c(20,19))\n  return (points)\n}\n\n#' @export\ngetEdges=function() {\n  edges=matrix(c(1,2),ncol=2)\n  edges=rbind(edges,c(1,4))\n  edges=rbind(edges,c(1,6))\n  edges=rbind(edges,c(2,4))\n  edges=rbind(edges,c(2,5))\n  edges=rbind(edges,c(3,5))\n  edges=rbind(edges,c(3,7))\n  edges=rbind(edges,c(4,6))\n  edges=rbind(edges,c(4,8))\n  edges=rbind(edges,c(5,7))\n  edges=rbind(edges,c(5,9))\n  edges=rbind(edges,c(6,12))\n  edges=rbind(edges,c(7,11))\n  edges=rbind(edges,c(7,13))\n  edges=rbind(edges,c(8,9))\n  edges=rbind(edges,c(8,10))\n  edges=rbind(edges,c(9,11))\n  edges=rbind(edges,c(10,12))\n  edges=rbind(edges,c(10,14))\n  edges=rbind(edges,c(11,13))\n  edges=rbind(edges,c(11,15))\n  edges=rbind(edges,c(12,16))\n  edges=rbind(edges,c(13,18))\n  edges=rbind(edges,c(14,15))\n  edges=rbind(edges,c(14,16))\n  edges=rbind(edges,c(15,17))\n  edges=rbind(edges,c(16,19))\n  edges=rbind(edges,c(16,22))\n  edges=rbind(edges,c(17,18))\n  edges=rbind(edges,c(17,19))\n  edges=rbind(edges,c(17,20))\n  edges=rbind(edges,c(18,21))\n  edges=rbind(edges,c(19,20))\n  edges=rbind(edges,c(19,22))\n  edges=rbind(edges,c(20,23))\n  edges=rbind(edges,c(21,23))\n  edges=rbind(edges,c(21,29))\n  edges=rbind(edges,c(22,24))\n  edges=rbind(edges,c(22,27))\n  edges=rbind(edges,c(23,24))\n  edges=rbind(edges,c(23,25))\n  edges=rbind(edges,c(24,25))\n  edges=rbind(edges,c(24,27))\n  edges=rbind(edges,c(25,26))\n  edges=rbind(edges,c(25,27))\n  edges=rbind(edges,c(25,28))\n  edges=rbind(edges,c(26,28))\n  edges=rbind(edges,c(26,29))\n  edges=rbind(edges,c(27,30))\n  edges=rbind(edges,c(27,31))\n  edges=rbind(edges,c(28,31))\n  edges=rbind(edges,c(28,32))\n  edges=rbind(edges,c(29,32))\n  edges=rbind(edges,c(29,35))\n  edges=rbind(edges,c(30,31))\n  edges=rbind(edges,c(30,34))\n  edges=rbind(edges,c(31,33))\n  edges=rbind(edges,c(31,34))\n  edges=rbind(edges,c(32,33))\n  edges=rbind(edges,c(32,35))\n  edges=rbind(edges,c(33,35))\n  edges=rbind(edges,c(33,36))\n  edges=rbind(edges,c(33,37))\n  edges=rbind(edges,c(34,36))\n  edges=rbind(edges,c(34,38))\n  edges=rbind(edges,c(35,40))\n  edges=rbind(edges,c(36,37))\n  edges=rbind(edges,c(36,39))\n  edges=rbind(edges,c(37,39))\n  edges=rbind(edges,c(37,40))\n  edges=rbind(edges,c(38,39))\n  \n  return (edges)\n}\n\n#' @export\ngetProbs=function(){\n  salinity=cbind(runif(40,100,200),runif(40,5,30))\n  phosphate=cbind(runif(40,100,200),runif(40,5,30))\n  nitrogen=cbind(runif(40,100,200),runif(40,5,30))\n  list(salinity=salinity,phosphate=phosphate,nitrogen=nitrogen)\n}\n\n#' @export\ngetReadings=function(point,probs){\n  c(\n    rnorm(1,probs$salinity[as.numeric(point),1],probs$salinity[as.numeric(point),2]),\n    rnorm(1,probs$phosphate[as.numeric(point),1],probs$phosphate[as.numeric(point),2]),\n    rnorm(1,probs$nitrogen[as.numeric(point),1],probs$nitrogen[as.numeric(point),2])\n  )\n}\n\n\n#' @export\nplotGameboard=function(points,edges,move,positions,showCroc) {\n  plot(points,pch=18,col=\"blue\",cex=2,xlab=\"X\",ylab=\"Y\",main=paste(\"Where's Croc - Move\",move))\n  xFrom=points[edges[,1],1]\n  yFrom=points[edges[,1],2]\n  xTo=points[edges[,2],1]\n  yTo=points[edges[,2],2]\n  segments(xFrom,yFrom,xTo,yTo)\n  for (bp in 2:3)\n    if (!is.na(positions[bp])) {\n      if (positions[bp]>0) {\n        points(points[as.numeric(positions[bp]),1],points[as.numeric(positions[bp]),2],col=\"orange\",pch=17,cex=4)\n      } else {\n        points(points[-as.numeric(positions[bp]),1],points[-as.numeric(positions[bp]),2],col=\"red\",pch=17,cex=4)\n      }\n    }\n  points(points[as.numeric(positions[4]),1],points[as.numeric(positions[4]),2],col=\"green\",pch=15,cex=4)\n  if (showCroc) {\n    points(points[as.numeric(positions[1]),1],points[as.numeric(positions[1]),2],col=\"red\",pch=15,cex=4)      \n  }\n  text(points[,1]+.4, points[,2], labels=as.character(1:40))\n}\n\n#' @export\ngetOptions=function(point,edges) {\n  c(edges[which(edges[,1]==point),2],edges[which(edges[,2]==point),1],point)\n}",
    "created" : 1507652603249.000,
    "dirty" : true,
    "encoding" : "UTF-8",
    "folds" : "6|60|9|0|\n12|60|35|0|\n37|56|66|0|\n68|45|93|0|\n95|54|107|0|\n109|45|120|0|\n122|86|149|0|\n151|91|168|0|\n330|22|372|0|\n375|21|449|0|\n452|20|457|0|\n470|62|490|0|\n",
    "hash" : "3244437336",
    "id" : "3A1029C0",
    "lastKnownWriteTime" : 1508013331,
    "last_content_update" : 1508013347173,
    "path" : "~/OneDrive - Uppsala universitet/Uppsala University/Semester 1/Period 1/Artificial Intelligence/Assignments/Assignment 2/DeliveryMan/R/WheresCroc.R",
    "project_path" : "R/WheresCroc.R",
    "properties" : {
    },
    "relative_order" : 1,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}